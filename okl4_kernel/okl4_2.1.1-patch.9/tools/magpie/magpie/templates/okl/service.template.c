!!explicit_linebreaks
/* \n
 * This is an automatically-generated file.\n
 * Source file  : {*-?generator.get_idl_filename()-*}\n
 * Output file  : {*-?generator.get_output_filename()-*}\n
 * Platform     : V4 Generic (big UUID)\n
 * Mapping      : {*-?templates.MAPPING-*}\n
 *\n
 * Generated by {*-?file.version_string-*}\n
*/\n
\n
#define IDL4_OMIT_FRAME_POINTER 0 /* Unimplemented */\n
#define IDL4_USE_FASTCALL 0 /* Unimplemented */\n
#define IDL4_NEED_MALLOC 0 /* Unimplemented */\n
#define IDL4_API v4\n
#define IDL4_ARCH generic_biguuid\n
\n
#ifdef __cplusplus\n
extern "C" {\n
#endif\n
#include "idl4biguuid/idl4.h"\n
#include "idl4biguuid/magpie.h"\n
#include "l4/message.h"\n
#ifdef __cplusplus\n
}\n
#endif\n
#include <stdio.h>\n
\n
/*LOOP importname = generator.get_imports()*/
#include "/*-?importname-*/"\n
/*ENDLOOP*/
\n
/*-
 # Define all integer constants as C preprocessor #defines.  
 # This can be used to get around the fact that you can't switch on const
 # ints in C, but only on int literals.
-*/
/*LOOP type_ast = generator.search( ['type_instance', {'meta_type': 'const'}] )*/
/*-basic_type = type_ast.the('target').the('type')-*/
/*-if basic_type.leaf in ('int', 'unsigned int', 'long', 'unsigned long', 'signed int', 'signed long')*/
#define _C_/*-?type_ast.leaf.upper()-*/ /*-?flatten(type_ast.the('declarator').the('expression'))-*/\n
#define /*-?type_ast.leaf.upper()-*/ /*-?flatten(type_ast.the('declarator').the('expression'))-*/\n
/*fi-*/
/*ENDLOOP*/
#define L4_REQUEST_MASK		( ~((~0UL) >> ((sizeof (L4_Word_t) * 8) - 20)))\n
#define L4_PAGEFAULT		(-(2UL << 20))\n
/*-if generator.get_word_size() == 32*/
#define L4_IRQ  0xFFF00000\n
#define L4_EXCEPTION 0xFFB00000\n
/*fi-*/
/*-if generator.get_word_size() == 64*/
#define L4_IRQ 0xFFFFFFFFFFF00000\n
#define L4_EXCEPTION 0xFFFFFFFFFFB00000\n
/*fi-*/
/*-if generator.get_word_size() not in (32, 64)*/
#define L4_IRQ (((~(0UL)) << 20))\n
#define L4_EXCEPTION (-(5UL << 20))\n
/*fi-*/
\n
#if defined(__arm) && __ARMCC_VERSION >= 200000 && !defined(__GNUC__)\n
/* rvct doesn't support inline, only __inline. */\n
#define inline __inline\n
#endif\n
\n
/* Magpie service main loop. */\n
\n
/*LOOP interface = generator.get_interfaces()*/
/* Interface {*-?interface.get_name()-*} */\n
/*LOOP function = interface.get_functions()*/
\n
/*-
if function.get_is_pagefault():
	unmarshal_start = 1
else:
	unmarshal_start = 2
-*/
/*-
if function.get_is_pagefault():
	# No UUID for pagefaults.
	msg_params_in = []
else:
	msg_params_in = [('long', '_uuid')]

msg_params_in.extend([(item['typename'], '%s%s' % (item['indirection'], item['name'])) for item in function.get_params_in()])

msg_params_out = [(item['typename'], '%s%s' % (item['indirection'], item['name'])) for item in function.get_params_out()]

msg_params_inout = [(item['typename'], '%s%s' % (item['indirection'], item['name'])) for item in function.get_params_inout()]

if function.get_return_type() != 'void':
	msg_params_out.append( (function.get_return_type(), '__retval') )
-*/

/*-function_implementation_name = function.get_name() + '_impl' -*/

/*-func_signature= ', '.join (['L4_ThreadId_t caller'] + ['%s %s' % (param.c_typename, param['name']) for param in function.get_call_params()] + ['idl4_server_environment *env'])-*/
/* Prototype for the function which implements this service. Implement this. */\n
/*-?function.get_return_type()-*/ /*-?function_implementation_name-*/(/*-?func_signature-*/);\n
\n
/*-func_paramlist = []
for item in function.get_params():
	if item['direction'] == 'return':
		continue # Ignore return parameters
	dereference = item['c_impl_indirection'].replace('*', '&')
	if 'priv' in item['flags']:
		param_name = '(mr[0] >> 16) & 7'
	else:
		param_name = '%s%s' % (dereference, item['name'])
	func_paramlist.append(param_name)
func_paramlist.append('&env')

-*/

/*-FUNCTION_NAME = function.get_name().upper() -*/
\n
/*-if function.get_is_pagefault()*/
/* Pagefault handler */\n
/*-run(templates.get('service_pagefault'))-*/
/*fi-*/
/*-if not function.get_is_pagefault()*/
static inline int\n
handle_/*-?function.get_name()-*/(L4_ThreadId_t *caller, byte *mr)\n
{\n
/*LOOP item = function.get_params(ignore = 'priv')*/
/*-if not (item['typename'] == 'void' and not item['indirection'])*/
	/*-?item.c_base_typename-*/ /*-?item['indirection']-*/ /*-?item['name']-*/;\n
/*fi-*/
/*ENDLOOP*/
	idl4_server_environment env;\n
/*-if function.has_varlength_params_in()*/
	byte *mr_varptr = mr; /* Variable-length param buffer pointer */\n
/*fi-*/
	env._action = 0;\n
\n
	/* Unmarshal */\n
/*LOOP cmd, args = function.unmarshal('in', startword = 2, client_side = False)*/
	/*-run(templates.get(cmd), args = args)-*/
/*ENDLOOP*/
\n
	/*-if function.get_return_type() != 'void'*/__return = /*fi-*/
/*-?function_implementation_name-*/(/*-?', '.join(['*caller'] + func_paramlist)-*/);\n
\n
	if(env._action == 0) {\n
		/* Marshal */\n
/*LOOP cmd, args = function.marshal('out', startword = 1, client_side = False)*/
		/*-run(templates.get(cmd), args = args)-*/
/*ENDLOOP*/
		/* Return number of return MRs used */\n
/*-if function.has_varlength_params_out()*/
		/* Number of registers used depends on length of variable-length portion */\n
		*((L4_Word_t *)(void *)(&mr[0])) = ((L4_Word_t)(mr_varptr - mr) / sizeof(L4_Word_t));\n
	/*fi-*/
/*-if not function.has_varlength_params_out()*/
		*((L4_Word_t *)(void *)(&mr[0])) = 1 + /*-? function.marshal_size_inwords_out()-*/;\n
/*fi-*/
	} else {\n
		*caller = L4_nilthread;\n
		mr[0] = 0;\n
	}\n
	return 0;\n
}\n
\n
/* End of function {*-?function.get_name()-*}*/\n

/*fi-*/
/*ENDLOOP*/
\n
/*ENDLOOP*/

/* Service template helper functions. */\n
/*-pagefault_handler = generator.get_pagefault_handler()-*/
/*-irq_handler =  generator.get_irq_handler()-*/
/*-exception_handler =  generator.get_exception_handler()-*/
/*-unknown_ipc_handler =  generator.get_unknown_ipc_handler()-*/
/*-async_handler = generator.get_async_handler()-*/
/*-workloop_function = generator.get_workloop_function()-*/

/*-if irq_handler*/
void /*-?generator.get_irq_handler_name()-*/(L4_ThreadId_t);\n
/*fi-*/

/*-if exception_handler*/
void /*-?exception_handler-*/(L4_ThreadId_t *, L4_Word_t *);\n
/*fi-*/

/*-if unknown_ipc_handler*/
void /*-?unknown_ipc_handler-*/(L4_ThreadId_t *, L4_Word_t *);\n
/*fi-*/

/*-if async_handler*/
void /*-?generator.get_async_handler_name()-*/(L4_Word_t);\n
/*fi-*/

/*-if workloop_function*/
void /*-?workloop_function-*/(void);\n
/*fi-*/
\n
static inline unsigned\n
msg_is_error(L4_MsgTag_t msgtag)\n
{\n
	return (msgtag.X.flags & 8);\n
}\n
\n
#define GET_ERROR_PHASE(code) ((code & 0x1))\n
#define GET_ERROR_CODE(code) ((code & (7 << 1)) >> 1)\n
\n
static inline void\n
print_error_info(L4_Word_t code)\n
{\n
#if 0\n
	if (GET_ERROR_PHASE(code) != 1){\n
		printf("Error in receive phase\n");\n
	}else{\n
		printf("Error in send phase\n");\n
	}\n
\n
	if (GET_ERROR_CODE(code) == 1){\n
		printf("No Partner - see p54 manual\n");\n
	}\n
	if (GET_ERROR_CODE(code) == 2){\n
		printf("Non-existing partner - see p54 manual\n");\n
	}\n
	if (GET_ERROR_CODE(code) == 3){\n
		printf("Cancelled by another thread (exreg) - see p54 manual\n");\n
	}\n
	if(GET_ERROR_CODE(code) == 4){\n
		printf("Overflow error, too many MRs required\n");\n
	}\n
	if (GET_ERROR_CODE(code) == 5){\n
		printf("Not accepted by another thread (async) - see p54 manual\n");\n
	}\n
	if (GET_ERROR_CODE(code) == 7){\n
		printf("Aborted by another thread (exreg) - see p54 manual\n");\n
	}\n
#endif\n
}\n
\n
static inline unsigned\n
get_function_id(L4_MsgTag_t msgtag)\n
{\n
	return (msgtag.X.label & ((1<<IDL4_FID_BITS)-1));\n
}\n
\n
\n
static inline int\n
magpie_unknown_ipc(L4_ThreadId_t *partner, L4_Word_t *mr)\n
{\n
/*-if unknown_ipc_handler*/
	/*-?unknown_ipc_handler-*/(partner, mr);\n
/*fi-*/
/*-if not unknown_ipc_handler*/
	/* Handler for unknown IPCs. Right now we just don't reply */
	*partner = L4_nilthread;\n
/*fi-*/
	return 0;\n
}\n
\n
/* Dispatchers for individual interfaces */\n
/*LOOP interface = generator.get_interfaces()*/\n
\n
\n
static inline int\n
dispatch_/*-?interface.get_name()-*/(L4_ThreadId_t *partner, byte *mr)\n
{\n
	L4_MsgTag_t *tag = (void *)mr;\n
	switch(get_function_id(*tag) ){\n
/*LOOP function = interface.get_functions()*/
/*-if not function.get_is_pagefault()*/
		case /*-?function.get_number()-*/:\n
			handle_/*-?function.get_name()-*/(partner, mr);\n
			break;\n
/*fi-*/
/*ENDLOOP*/
		default:\n
			magpie_unknown_ipc(partner, (L4_Word_t *)mr);\n
			break;\n
	}\n
	return 0;\n
}\n
/*ENDLOOP*/
/*-if pagefault_handler*/
\n
\n
static inline int\n
dispatch__kernel_pagefault(L4_ThreadId_t *partner, L4_Word_t *mr)\n
{\n
	uintptr_t addr;\n
	uintptr_t ip;\n
	uintptr_t priv;\n
	idl4_server_environment env;\n
	idl4_mapitem fp;\n
\n
    env._action = 0;\n
	addr = (uintptr_t)mr[1];\n
	ip = (uintptr_t)mr[2];\n
	priv = (mr[0] >> 16) & 7;\n
\n
	/* Handle pagefaults, sent differently to regular messages. */\n
	/* Use V4/N2 encoding. */\n
	/*-?pagefault_handler.get_name()-*/_impl(*partner, addr, ip, priv, &fp, &env);\n
\n
	if(env._action == 0) {\n
		mr[0] = 2;\n
		mr[1] = fp.base;\n
		mr[2] = fp.fpage;\n
	} else {\n
		*partner = L4_nilthread;\n
		mr[0] = 0;\n
	}\n
\n
	return mr[0];\n
}\n
/*fi-*/

\n
\n
/* Service template mainloop. */\n
void /*-?generator.get_server_loop_name()-*/(void);\n
void\n
/*-?generator.get_server_loop_name()-*/(void)\n
{\n
	L4_Word_t *mr = (void *)L4_MRStart();\n
	L4_ThreadId_t partner = L4_nilthread; /* Our initial reply is to the nilthread. */\n
	L4_MsgTag_t tag;\n
\n
	while(1) {\n
/*-if workloop_function*/
		/* Call the server-defined workloop function which runs after every message. */\n
		/*-?workloop_function-*/();\n
/*fi-*/
		/* Send response to previous message, if any, and wait for new mesage.*/\n
		L4_ReplyWait(partner, &partner);\n
		tag = *((L4_MsgTag_t *)(void *)mr);\n
		if (msg_is_error(tag)) {\n
			/* FIXME: nfd - fix error handling */\n
#if 0\n
			printf("%s: server: error sending IPC reply\n", __FILE__);\n
#endif\n
			print_error_info(L4_ErrorCode());\n
			partner = L4_nilthread;\n
/*-if pagefault_handler*/
		} else if ((mr[0] & L4_REQUEST_MASK) == L4_PAGEFAULT) {\n
			dispatch__kernel_pagefault(&partner, mr);\n
/*fi-*/
/*-if async_handler*/
		} else if (partner.raw == 0) {\n
				/*-?generator.get_async_handler_name()-*/(mr[1]);\n
/*fi-*/
/*-if irq_handler*/
		} else if ((mr[0] & L4_REQUEST_MASK) == L4_IRQ) {\n
			/*-?generator.get_irq_handler_name()-*/(partner);\n
/*fi-*/
/*-if exception_handler*/
		} else if ((mr[0] & L4_REQUEST_MASK) == L4_EXCEPTION) {\n
			/*-?exception_handler-*/(&partner, mr);\n
/*fi-*/
		} else {\n
			/* mr[1] contains the interface UUID - switch on that first. */\n
			switch(mr[1]) {\n
/*LOOP interface = generator.get_interfaces()*/
				case /*-?interface.get_uuid()-*/:\n
					dispatch_/*-?interface.get_name()-*/(&partner, (void *)mr);\n
					break;\n
/*ENDLOOP*/
				default:\n
					magpie_unknown_ipc(&partner, mr);\n
					break;\n
			}\n
		}\n
	}\n
}\n


