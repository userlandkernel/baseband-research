/* 
 * This is an automatically-generated file.
 * Source file REMOVED_FOR_TESTING
 * Output file  : -
 * Platform     : V4 ARM (big UUID)
 * Mapping      : CORBA C
 *
 * Generated by Magpie VERSION_REMOVED
*/

#define IDL4_OMIT_FRAME_POINTER 0 /* Unimplemented */
#define IDL4_USE_FASTCALL 0 /* Unimplemented */
#define IDL4_NEED_MALLOC 0 /* Unimplemented */
#define IDL4_API v4
#define IDL4_ARCH arm_biguuid


#define MAGPIE_BYTES_PER_WORD (sizeof(L4_Word_t))

/* This from $pistachio/include/l4/arm/syscalls.h */
#define MAGPIE__L4_SYSCALL                   \
        "str    fp,     [sp, #-4]! \n" \
        "mov    lr,     pc         \n" \
        "mov    pc,     ip         \n" \
        "ldr    fp,     [sp],   #4 \n"

#ifdef __cplusplus
extern "C" {
#endif
#include "idl4biguuid_arm/idl4.h"
#ifdef __cplusplus
}
#endif



#include "char_ptr_arg_2.h"



#if !defined(__-__)
#define __-__




/* Interface iguana_thread */
#if !defined(_objdef___iguana_thread)
#define _objdef___iguana_thread
typedef CORBA_Object iguana_thread;
#endif // !defined(_objdef___iguana_thread)




#if !defined(_funcdef___iguana_thread_id)
#define _funcdef___iguana_thread_id
/* Biguuid generic code: _MAGPIE_IGUANA_THREAD_ID_CALL_ID is simply the function number.
 * The interface ID is encoded as a separate input parameter. 
*/
#define _MAGPIE_IGUANA_THREAD_ID_CALL_ID (0u)

static inline thread_ref_t iguana_thread_id (iguana_thread _service, L4_ThreadId_t thread, CORBA_Environment *_env)
{



	register L4_ThreadId_t ipc_dest asm("r0") = _service;
	register L4_ThreadId_t ipc_FromSpecifier asm("r1") = _service;
	register L4_Word_t ipc_Timeouts asm("r2") = L4_Timeouts(L4_Never, L4_Never);
	register L4_MsgTag_t client_msgtag asm("r3");
	register L4_Word_t r_mr1 asm("r4"); /* UUID on input and (sometimes) result on output */ 
	register L4_Word_t r_mr2 asm("r5"); 
	
	
	register __L4_Ipc_t r_syscall asm("r12") = __L4_Ipc;
	L4_Word_t _asynch_mask;
	

#if 0
	/* Self-check code */
	union _MAGPIE_IGUANA_THREAD_ID_arm_buf {
		struct {
			long _msgtag;
			long _uuid;
			L4_ThreadId_t thread;
		} _in;
		struct {
			long _msgtag;
			thread_ref_t __retval;
		} _out;
	} __MAGPIE_IGUANA_THREAD_ID_arm_pack;
	assert( ((sizeof(__MAGPIE_IGUANA_THREAD_ID_arm_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) == (1 + 1));
	assert( ((sizeof(__MAGPIE_IGUANA_THREAD_ID_arm_pack._out) - sizeof(long)) /
MAGPIE_BYTES_PER_WORD) == (1) );
	/* End of self-check code */
#endif

	/* Calculate the message tag for parameter 1*/
	client_msgtag.raw = ((_MAGPIE_IGUANA_THREAD_ID_CALL_ID) << 16) + 1 + 1; /* Add 1 for UUID */
	/* Copy all inputs into registers, starting with UUID. NB the pass-by-reference case is evil*/ 
	r_mr1 = 24;

	r_mr2 =  ((L4_Word_t)thread);
	
	/* Call L4 IPC directly using the __L4_SYSCALL macro
	* defined in include/l4/arm/syscalls.h */
	
	
	__asm__ __volatile (
		MAGPIE__L4_SYSCALL 
		: "=r" (ipc_dest), "=r" (client_msgtag), "=r" (r_mr1),
			"=r" (ipc_FromSpecifier), "=r" (ipc_Timeouts), "=r" (r_syscall)
		: "r" (client_msgtag), "r" (r_mr1), "r" (r_mr2),
			"r" (r_syscall), "r" (ipc_dest), "r" (ipc_FromSpecifier), "r" (ipc_Timeouts)
		: "r6", "r7", "lr", "r8", "r9", "r10" /* r8, r9, r10 constitute __L4_ALWAYS_CLOBBER */
	);
	
	/* Copy results from output registers. */ 
	
	/* Result fits in a single register. */
	return (thread_ref_t)r_mr1;
	
	


}
#endif // !defined(_funcdef___iguana_thread_id)





#if !defined(_funcdef___iguana_thread_l4id)
#define _funcdef___iguana_thread_l4id
/* Biguuid generic code: _MAGPIE_IGUANA_THREAD_L4ID_CALL_ID is simply the function number.
 * The interface ID is encoded as a separate input parameter. 
*/
#define _MAGPIE_IGUANA_THREAD_L4ID_CALL_ID (1u)

static inline L4_ThreadId_t iguana_thread_l4id (iguana_thread _service, thread_ref_t thread, CORBA_Environment *_env)
{



	register L4_ThreadId_t ipc_dest asm("r0") = _service;
	register L4_ThreadId_t ipc_FromSpecifier asm("r1") = _service;
	register L4_Word_t ipc_Timeouts asm("r2") = L4_Timeouts(L4_Never, L4_Never);
	register L4_MsgTag_t client_msgtag asm("r3");
	register L4_Word_t r_mr1 asm("r4"); /* UUID on input and (sometimes) result on output */ 
	register L4_Word_t r_mr2 asm("r5"); 
	
	
	register __L4_Ipc_t r_syscall asm("r12") = __L4_Ipc;
	L4_Word_t _asynch_mask;
	

#if 0
	/* Self-check code */
	union _MAGPIE_IGUANA_THREAD_L4ID_arm_buf {
		struct {
			long _msgtag;
			long _uuid;
			thread_ref_t thread;
		} _in;
		struct {
			long _msgtag;
			L4_ThreadId_t __retval;
		} _out;
	} __MAGPIE_IGUANA_THREAD_L4ID_arm_pack;
	assert( ((sizeof(__MAGPIE_IGUANA_THREAD_L4ID_arm_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) == (1 + 1));
	assert( ((sizeof(__MAGPIE_IGUANA_THREAD_L4ID_arm_pack._out) - sizeof(long)) /
MAGPIE_BYTES_PER_WORD) == (1) );
	/* End of self-check code */
#endif

	/* Calculate the message tag for parameter 1*/
	client_msgtag.raw = ((_MAGPIE_IGUANA_THREAD_L4ID_CALL_ID) << 16) + 1 + 1; /* Add 1 for UUID */
	/* Copy all inputs into registers, starting with UUID. NB the pass-by-reference case is evil*/ 
	r_mr1 = 24;

	r_mr2 =  ((L4_Word_t)thread);
	
	/* Call L4 IPC directly using the __L4_SYSCALL macro
	* defined in include/l4/arm/syscalls.h */
	
	
	__asm__ __volatile (
		MAGPIE__L4_SYSCALL 
		: "=r" (ipc_dest), "=r" (client_msgtag), "=r" (r_mr1),
			"=r" (ipc_FromSpecifier), "=r" (ipc_Timeouts), "=r" (r_syscall)
		: "r" (client_msgtag), "r" (r_mr1), "r" (r_mr2),
			"r" (r_syscall), "r" (ipc_dest), "r" (ipc_FromSpecifier), "r" (ipc_Timeouts)
		: "r6", "r7", "lr", "r8", "r9", "r10" /* r8, r9, r10 constitute __L4_ALWAYS_CLOBBER */
	);
	
	/* Copy results from output registers. */ 
	
	/* Result fits in a single register. */
	return (L4_ThreadId_t)r_mr1;
	
	


}
#endif // !defined(_funcdef___iguana_thread_l4id)





#if !defined(_funcdef___iguana_thread_set_handle)
#define _funcdef___iguana_thread_set_handle
/* Biguuid generic code: _MAGPIE_IGUANA_THREAD_SET_HANDLE_CALL_ID is simply the function number.
 * The interface ID is encoded as a separate input parameter. 
*/
#define _MAGPIE_IGUANA_THREAD_SET_HANDLE_CALL_ID (2u)

static inline void iguana_thread_set_handle (iguana_thread _service, L4_ThreadId_t thrd_id, char *handle, CORBA_Environment *_env)
{



	register L4_ThreadId_t ipc_dest asm("r0") = _service;
	register L4_ThreadId_t ipc_FromSpecifier asm("r1") = _service;
	register L4_Word_t ipc_Timeouts asm("r2") = L4_Timeouts(L4_Never, L4_Never);
	register L4_MsgTag_t client_msgtag asm("r3");
	register L4_Word_t r_mr1 asm("r4"); /* UUID on input and (sometimes) result on output */ 
	register L4_Word_t r_mr2 asm("r5"); 
	register L4_Word_t r_mr3 asm("r6"); 
	
	register __L4_Ipc_t r_syscall asm("r12") = __L4_Ipc;
	L4_Word_t _asynch_mask;
	

#if 0
	/* Self-check code */
	union _MAGPIE_IGUANA_THREAD_SET_HANDLE_arm_buf {
		struct {
			long _msgtag;
			long _uuid;
			L4_ThreadId_t thrd_id;
			char *handle;
		} _in;
		struct {
			long _msgtag;
			
		} _out;
	} __MAGPIE_IGUANA_THREAD_SET_HANDLE_arm_pack;
	assert( ((sizeof(__MAGPIE_IGUANA_THREAD_SET_HANDLE_arm_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) == (2 + 1));
	assert( ((sizeof(__MAGPIE_IGUANA_THREAD_SET_HANDLE_arm_pack._out) - sizeof(long)) /
MAGPIE_BYTES_PER_WORD) == (0) );
	/* End of self-check code */
#endif

	/* Calculate the message tag for parameter 1*/
	client_msgtag.raw = ((_MAGPIE_IGUANA_THREAD_SET_HANDLE_CALL_ID) << 16) + 2 + 1; /* Add 1 for UUID */
	/* Copy all inputs into registers, starting with UUID. NB the pass-by-reference case is evil*/ 
	r_mr1 = 24;

	r_mr2 =  ((L4_Word_t)thrd_id);
	

	r_mr3 =  ((L4_Word_t)handle);
	
	/* Call L4 IPC directly using the __L4_SYSCALL macro
	* defined in include/l4/arm/syscalls.h */
	
	
	__asm__ __volatile (
		MAGPIE__L4_SYSCALL 
		: "=r" (ipc_dest), "=r" (client_msgtag),
			"=r" (ipc_FromSpecifier), "=r" (ipc_Timeouts), "=r" (r_syscall)
		: "r" (client_msgtag), "r" (r_mr1), "r" (r_mr2), "r" (r_mr3),
			"r" (r_syscall), "r" (ipc_dest), "r" (ipc_FromSpecifier), "r" (ipc_Timeouts)
		: "r7", "lr", "r8", "r9", "r10" /* r8, r9, r10 constitute __L4_ALWAYS_CLOBBER */
	);
	
	/* Copy results from output registers. */ 
	
	


}
#endif // !defined(_funcdef___iguana_thread_set_handle)





#if !defined(_funcdef___iguana_thread_getId_from_handle)
#define _funcdef___iguana_thread_getId_from_handle
/* Biguuid generic code: _MAGPIE_IGUANA_THREAD_GETID_FROM_HANDLE_CALL_ID is simply the function number.
 * The interface ID is encoded as a separate input parameter. 
*/
#define _MAGPIE_IGUANA_THREAD_GETID_FROM_HANDLE_CALL_ID (3u)

static inline L4_ThreadId_t iguana_thread_getId_from_handle (iguana_thread _service, char *handle, CORBA_Environment *_env)
{



	register L4_ThreadId_t ipc_dest asm("r0") = _service;
	register L4_ThreadId_t ipc_FromSpecifier asm("r1") = _service;
	register L4_Word_t ipc_Timeouts asm("r2") = L4_Timeouts(L4_Never, L4_Never);
	register L4_MsgTag_t client_msgtag asm("r3");
	register L4_Word_t r_mr1 asm("r4"); /* UUID on input and (sometimes) result on output */ 
	register L4_Word_t r_mr2 asm("r5"); 
	
	
	register __L4_Ipc_t r_syscall asm("r12") = __L4_Ipc;
	L4_Word_t _asynch_mask;
	

#if 0
	/* Self-check code */
	union _MAGPIE_IGUANA_THREAD_GETID_FROM_HANDLE_arm_buf {
		struct {
			long _msgtag;
			long _uuid;
			char *handle;
		} _in;
		struct {
			long _msgtag;
			L4_ThreadId_t __retval;
		} _out;
	} __MAGPIE_IGUANA_THREAD_GETID_FROM_HANDLE_arm_pack;
	assert( ((sizeof(__MAGPIE_IGUANA_THREAD_GETID_FROM_HANDLE_arm_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) == (1 + 1));
	assert( ((sizeof(__MAGPIE_IGUANA_THREAD_GETID_FROM_HANDLE_arm_pack._out) - sizeof(long)) /
MAGPIE_BYTES_PER_WORD) == (1) );
	/* End of self-check code */
#endif

	/* Calculate the message tag for parameter 1*/
	client_msgtag.raw = ((_MAGPIE_IGUANA_THREAD_GETID_FROM_HANDLE_CALL_ID) << 16) + 1 + 1; /* Add 1 for UUID */
	/* Copy all inputs into registers, starting with UUID. NB the pass-by-reference case is evil*/ 
	r_mr1 = 24;

	r_mr2 =  ((L4_Word_t)handle);
	
	/* Call L4 IPC directly using the __L4_SYSCALL macro
	* defined in include/l4/arm/syscalls.h */
	
	
	__asm__ __volatile (
		MAGPIE__L4_SYSCALL 
		: "=r" (ipc_dest), "=r" (client_msgtag), "=r" (r_mr1),
			"=r" (ipc_FromSpecifier), "=r" (ipc_Timeouts), "=r" (r_syscall)
		: "r" (client_msgtag), "r" (r_mr1), "r" (r_mr2),
			"r" (r_syscall), "r" (ipc_dest), "r" (ipc_FromSpecifier), "r" (ipc_Timeouts)
		: "r6", "r7", "lr", "r8", "r9", "r10" /* r8, r9, r10 constitute __L4_ALWAYS_CLOBBER */
	);
	
	/* Copy results from output registers. */ 
	
	/* Result fits in a single register. */
	return (L4_ThreadId_t)r_mr1;
	
	


}
#endif // !defined(_funcdef___iguana_thread_getId_from_handle)





#if !defined(_funcdef___iguana_thread_clr_handle)
#define _funcdef___iguana_thread_clr_handle
/* Biguuid generic code: _MAGPIE_IGUANA_THREAD_CLR_HANDLE_CALL_ID is simply the function number.
 * The interface ID is encoded as a separate input parameter. 
*/
#define _MAGPIE_IGUANA_THREAD_CLR_HANDLE_CALL_ID (4u)

static inline int iguana_thread_clr_handle (iguana_thread _service, L4_ThreadId_t thrd_id, CORBA_Environment *_env)
{



	register L4_ThreadId_t ipc_dest asm("r0") = _service;
	register L4_ThreadId_t ipc_FromSpecifier asm("r1") = _service;
	register L4_Word_t ipc_Timeouts asm("r2") = L4_Timeouts(L4_Never, L4_Never);
	register L4_MsgTag_t client_msgtag asm("r3");
	register L4_Word_t r_mr1 asm("r4"); /* UUID on input and (sometimes) result on output */ 
	register L4_Word_t r_mr2 asm("r5"); 
	
	
	register __L4_Ipc_t r_syscall asm("r12") = __L4_Ipc;
	L4_Word_t _asynch_mask;
	

#if 0
	/* Self-check code */
	union _MAGPIE_IGUANA_THREAD_CLR_HANDLE_arm_buf {
		struct {
			long _msgtag;
			long _uuid;
			L4_ThreadId_t thrd_id;
		} _in;
		struct {
			long _msgtag;
			int __retval;
		} _out;
	} __MAGPIE_IGUANA_THREAD_CLR_HANDLE_arm_pack;
	assert( ((sizeof(__MAGPIE_IGUANA_THREAD_CLR_HANDLE_arm_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) == (1 + 1));
	assert( ((sizeof(__MAGPIE_IGUANA_THREAD_CLR_HANDLE_arm_pack._out) - sizeof(long)) /
MAGPIE_BYTES_PER_WORD) == (1) );
	/* End of self-check code */
#endif

	/* Calculate the message tag for parameter 1*/
	client_msgtag.raw = ((_MAGPIE_IGUANA_THREAD_CLR_HANDLE_CALL_ID) << 16) + 1 + 1; /* Add 1 for UUID */
	/* Copy all inputs into registers, starting with UUID. NB the pass-by-reference case is evil*/ 
	r_mr1 = 24;

	r_mr2 =  ((L4_Word_t)thrd_id);
	
	/* Call L4 IPC directly using the __L4_SYSCALL macro
	* defined in include/l4/arm/syscalls.h */
	
	
	__asm__ __volatile (
		MAGPIE__L4_SYSCALL 
		: "=r" (ipc_dest), "=r" (client_msgtag), "=r" (r_mr1),
			"=r" (ipc_FromSpecifier), "=r" (ipc_Timeouts), "=r" (r_syscall)
		: "r" (client_msgtag), "r" (r_mr1), "r" (r_mr2),
			"r" (r_syscall), "r" (ipc_dest), "r" (ipc_FromSpecifier), "r" (ipc_Timeouts)
		: "r6", "r7", "lr", "r8", "r9", "r10" /* r8, r9, r10 constitute __L4_ALWAYS_CLOBBER */
	);
	
	/* Copy results from output registers. */ 
	
	/* Result fits in a single register. */
	return (int)r_mr1;
	
	


}
#endif // !defined(_funcdef___iguana_thread_clr_handle)





#if !defined(_funcdef___iguana_thread_start)
#define _funcdef___iguana_thread_start
/* Biguuid generic code: _MAGPIE_IGUANA_THREAD_START_CALL_ID is simply the function number.
 * The interface ID is encoded as a separate input parameter. 
*/
#define _MAGPIE_IGUANA_THREAD_START_CALL_ID (5u)

static inline void iguana_thread_start (iguana_thread _service, thread_ref_t thread, uintptr_t ip, uintptr_t sp, CORBA_Environment *_env)
{



	register L4_ThreadId_t ipc_dest asm("r0") = _service;
	register L4_ThreadId_t ipc_FromSpecifier asm("r1") = _service;
	register L4_Word_t ipc_Timeouts asm("r2") = L4_Timeouts(L4_Never, L4_Never);
	register L4_MsgTag_t client_msgtag asm("r3");
	register L4_Word_t r_mr1 asm("r4"); /* UUID on input and (sometimes) result on output */ 
	register L4_Word_t r_mr2 asm("r5"); 
	register L4_Word_t r_mr3 asm("r6"); 
	register L4_Word_t r_mr4 asm("r7"); 
	register __L4_Ipc_t r_syscall asm("r12") = __L4_Ipc;
	L4_Word_t _asynch_mask;
	

#if 0
	/* Self-check code */
	union _MAGPIE_IGUANA_THREAD_START_arm_buf {
		struct {
			long _msgtag;
			long _uuid;
			thread_ref_t thread;
			uintptr_t ip;
			uintptr_t sp;
		} _in;
		struct {
			long _msgtag;
			
		} _out;
	} __MAGPIE_IGUANA_THREAD_START_arm_pack;
	assert( ((sizeof(__MAGPIE_IGUANA_THREAD_START_arm_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) == (3 + 1));
	assert( ((sizeof(__MAGPIE_IGUANA_THREAD_START_arm_pack._out) - sizeof(long)) /
MAGPIE_BYTES_PER_WORD) == (0) );
	/* End of self-check code */
#endif

	/* Calculate the message tag for parameter 1*/
	client_msgtag.raw = ((_MAGPIE_IGUANA_THREAD_START_CALL_ID) << 16) + 3 + 1; /* Add 1 for UUID */
	/* Copy all inputs into registers, starting with UUID. NB the pass-by-reference case is evil*/ 
	r_mr1 = 24;

	r_mr2 =  ((L4_Word_t)thread);
	

	r_mr3 =  ((L4_Word_t)ip);
	

	r_mr4 =  ((L4_Word_t)sp);
	
	/* Call L4 IPC directly using the __L4_SYSCALL macro
	* defined in include/l4/arm/syscalls.h */
	
	
	__asm__ __volatile (
		MAGPIE__L4_SYSCALL 
		: "=r" (ipc_dest), "=r" (client_msgtag),
			"=r" (ipc_FromSpecifier), "=r" (ipc_Timeouts), "=r" (r_syscall)
		: "r" (client_msgtag), "r" (r_mr1), "r" (r_mr2), "r" (r_mr3), "r" (r_mr4),
			"r" (r_syscall), "r" (ipc_dest), "r" (ipc_FromSpecifier), "r" (ipc_Timeouts)
		: "lr", "r8", "r9", "r10" /* r8, r9, r10 constitute __L4_ALWAYS_CLOBBER */
	);
	
	/* Copy results from output registers. */ 
	
	


}
#endif // !defined(_funcdef___iguana_thread_start)





#if !defined(_funcdef___iguana_thread_delete)
#define _funcdef___iguana_thread_delete
/* Biguuid generic code: _MAGPIE_IGUANA_THREAD_DELETE_CALL_ID is simply the function number.
 * The interface ID is encoded as a separate input parameter. 
*/
#define _MAGPIE_IGUANA_THREAD_DELETE_CALL_ID (6u)

static inline void iguana_thread_delete (iguana_thread _service, thread_ref_t thread, CORBA_Environment *_env)
{



	register L4_ThreadId_t ipc_dest asm("r0") = _service;
	register L4_ThreadId_t ipc_FromSpecifier asm("r1") = _service;
	register L4_Word_t ipc_Timeouts asm("r2") = L4_Timeouts(L4_Never, L4_Never);
	register L4_MsgTag_t client_msgtag asm("r3");
	register L4_Word_t r_mr1 asm("r4"); /* UUID on input and (sometimes) result on output */ 
	register L4_Word_t r_mr2 asm("r5"); 
	
	
	register __L4_Ipc_t r_syscall asm("r12") = __L4_Ipc;
	L4_Word_t _asynch_mask;
	

#if 0
	/* Self-check code */
	union _MAGPIE_IGUANA_THREAD_DELETE_arm_buf {
		struct {
			long _msgtag;
			long _uuid;
			thread_ref_t thread;
		} _in;
		struct {
			long _msgtag;
			
		} _out;
	} __MAGPIE_IGUANA_THREAD_DELETE_arm_pack;
	assert( ((sizeof(__MAGPIE_IGUANA_THREAD_DELETE_arm_pack._in) - sizeof(long)) / MAGPIE_BYTES_PER_WORD) == (1 + 1));
	assert( ((sizeof(__MAGPIE_IGUANA_THREAD_DELETE_arm_pack._out) - sizeof(long)) /
MAGPIE_BYTES_PER_WORD) == (0) );
	/* End of self-check code */
#endif

	/* Calculate the message tag for parameter 1*/
	client_msgtag.raw = ((_MAGPIE_IGUANA_THREAD_DELETE_CALL_ID) << 16) + 1 + 1; /* Add 1 for UUID */
	/* Copy all inputs into registers, starting with UUID. NB the pass-by-reference case is evil*/ 
	r_mr1 = 24;

	r_mr2 =  ((L4_Word_t)thread);
	
	/* Call L4 IPC directly using the __L4_SYSCALL macro
	* defined in include/l4/arm/syscalls.h */
	
	
	__asm__ __volatile (
		MAGPIE__L4_SYSCALL 
		: "=r" (ipc_dest), "=r" (client_msgtag),
			"=r" (ipc_FromSpecifier), "=r" (ipc_Timeouts), "=r" (r_syscall)
		: "r" (client_msgtag), "r" (r_mr1), "r" (r_mr2),
			"r" (r_syscall), "r" (ipc_dest), "r" (ipc_FromSpecifier), "r" (ipc_Timeouts)
		: "r6", "r7", "lr", "r8", "r9", "r10" /* r8, r9, r10 constitute __L4_ALWAYS_CLOBBER */
	);
	
	/* Copy results from output registers. */ 
	
	


}
#endif // !defined(_funcdef___iguana_thread_delete)





#endif //__-__
